package myleft.engine.utils {		import flash.display.Shape;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.utils.Dictionary;		public class GTween extends EventDispatcher {				[Event(name="activate", type="flash.events.Event")]		[Event(name="init", type="flash.events.Event")]				[Event(name="complete", type="flash.events.Event")]				[Event(name="progress", type="flash.events.Event")]		[Event(name="change", type="flash.events.Event")]			// constants:		/** Constant for the TIME timingMode. **/		public static const TIME:String = "time";		/** Constant for the FRAME timingMode. **/		public static const FRAME:String = "frame";		/** Constant for the HYBRID timingMode. **/		public static const HYBRID:String = "hybrid";		/** Constant for the BEGINNING state. **/		public static const BEGINNING:String = "beginning";		/** Constant for the DELAY_PHASE state. **/		public static const DELAY_PHASE:String = "delayPhase";		/** Constant for the TWEEN_PHASE state. **/		public static const TWEEN_PHASE:String = "tweenPhase";		/** Constant for the END state. **/		public static const END:String = "end";		/** Constant for the PROGRESS event type. **/		public static const PROGRESS:String = "progress";		// public static properties:		/** Setting this to true pauses all tween instances. This does not affect individual tweens' .paused property. **/		public static var pauseAll:Boolean=false;				/** A hash table specifying properties that should be affected by smartRotation. **/		public static var rotationProperties:Object = {_rotation:true,rotation:true,rotationX:true,rotationY:true,rotationZ:true};				/** A hash table specifying properties that should have their value rounded (snapped) before being applied. This can be toggled on a per instance basis with useSnapping. **/		public static var snappingProperties:Object = {x:true,y:true};				public static var defaultEase:Function=linearEase;				public static function get timingMode():String {			return _timingMode;		}		public static function set timingMode(value:String):void {			value = (value == FRAME || value == TIME) ? value : HYBRID;			if (value == _timingMode) { return; }			_timingMode = value;			if (_timingMode == TIME) {				ticker = new TimeTicker();				(ticker as TimeTicker).interval = _timeInterval/1000;			} else if (_timingMode == FRAME) {				ticker = new FrameTicker();			} else {				ticker = new HybridTicker();			}		}				public static function get timeInterval():uint {			return _timeInterval;		}		public static function set timeInterval(value:uint):void {			_timeInterval = value;			if (ticker is TimeTicker) { (ticker as TimeTicker).interval = _timeInterval/1000; }		}			// public static methods:		// default tween function:		/** The default easing function used by GTween. **/		public static function linearEase(value:Number, ...args:Array):Number {			return value;		}		// private static properties:		/** @private **/		protected static var activeTweens:Dictionary = new Dictionary(false); // keeps active tweens in memory		/** @private **/		protected static var _timingMode:String;		/** @private **/		protected static var _timeInterval:uint = 40;		/** @private **/		protected static var ticker:ITicker;				// public properties:		/**		* When true, the tween will always rotate in the shortest direction to reach the destination rotation.		* For example, rotating from 355 degress to 5 degrees will rotate 10 degrees clockwise with useSmartRotation set to true.		* It would rotate 350 degrees counter-clockwise with useSmartRotation set to false.		**/		public var useSmartRotation:Boolean = true;				/**		* Indicates whether the tween should automatically play when a destination value is changed.		**/		public var autoPlay:Boolean = true;				/**		* The transition function to use for calculating the tween. This can be any standard tween function, such as the tween functions in fl.motion.easing.* that come with Flash CS3.		* New tweens will have this set to the defaultTween. Setting this to null will cause GTween to throw null reference errors.		**/		public var ease:Function;				/**		* Specifies another GTween instance that will have .play() called on it when this tween completes.		**/		public var nextTween:GTween;				public var autoReverse:Boolean = false;				public var assignmentTarget:Object;				public var assignmentProperty:String;		public var useSnapping:Boolean = false;		public var useSetSize:Boolean = true;				/**		* Allows you to associate arbitrary data with your tween. For example, you might use this to reference specific data when handling events from tweens.		**/		public var data:*;		// private properties:		/** @private **/		protected var _target:Object;		/** @private **/		protected var _position:Number=0;		/** @private **/		protected var _duration:Number=10;		/** @private **/		protected var _lastProgressPoint:ProgressPoint;		/** @private **/		protected var _autoHide:Boolean=true;		/** @private **/		protected var _proxy:TargetProxy;		/** @private **/		protected var _paused:Boolean=true;		/** @private **/		protected var _state:String = BEGINNING;		/** @private **/		protected var _delay:Number = 0;		/** @private **/		protected var destProperties:Object; // stores the destination property values.		/** @private **/		protected var initProperties:Object; // stores the initial property values of the target.		/** @private **/		protected var invalid:Boolean=false;		/** @private **/		protected var children:Dictionary;		/** @private **/		protected var hasSetSize:Boolean = false;		/** @private **/		protected var hasAlphaAndVisible:Boolean = true;		/** @private **/		protected var progressPoints:Array;		/** @private **/		protected var lastProgressPosition:Number = 0;		/** @private **/		protected var positionOffset:Number = NaN; // indicates this tween's offset from the ticker position		/** @private **/		protected var ticker:ITicker; // maintains a local reference, in case the timingMode changes		/** @private **/		protected var clearProperties:Boolean = true;			// constructor:		public function GTween(target:Object=null, duration:Number=10, properties:Object=null, tweenProperties:Object=null) {			ease = defaultEase || linearEase;			if (isNaN(duration)) { duration = 10; }			if (_timingMode == null) { timingMode = HYBRID; }			ticker = GTween.ticker;			progressPoints = [];			children = new Dictionary(true);			this.target = target;			_duration = duration;			setTweenProperties(tweenProperties);			setProperties(properties);		}			// public getter/setters:		public function get proxy():Object {			if (_proxy == null) { _proxy = new TargetProxy(this); }			return _proxy;		}				public function get position():Number {			return _position;		}		public function set position(value:Number):void {			if (isNaN(value)) { return; }			value = (value > _duration) ? _duration : ((value < -_delay) ? -_delay : value);			if (_position == value) { return; }			lastProgressPosition = value;			setPosition(value);		}				public function get duration():Number {			return _duration;		}		public function set duration(value:Number):void {			if (isNaN(value)) { return; }			_duration = value;			for (var n:Object in children) {				if (children[n]) {					(n as GTween).duration = _duration;				}			}		}		public function get delay():Number {			return _delay;		}		public function set delay(value:Number):void {			if (isNaN(value)) { return; }			if (_state == BEGINNING || _position == -_delay) {				positionOffset = ticker.position-(_position = -value);				lastProgressPosition = -_delay;			}			_delay = value;		}				/**		* The target object to tween. This can be any kind of object.		**/		public function get target():Object {			return _target;		}		public function set target(value:Object):void {			_target = (value === null) ? {} : value;			hasSetSize = "setSize" in _target;			hasAlphaAndVisible = "alpha" in _target && "visible" in _target;			reset();		}				public function get autoHide():Boolean {			return _autoHide;		}		public function set autoHide(value:Boolean):void {			_autoHide = value;		}				/**		* Returns the name of the last progress point that was passed, or null if none.		**/		public function get lastProgressPoint():* {			return (_lastProgressPoint) ? _lastProgressPoint.data : null;		}				public function get state():String {			return _state;		}				/**		* Indicates whether the tween is currently paused (including when it is at the beginning or end). See play() and pause() for more information.		**/		public function get paused():Boolean {			return _paused;		}		public function set paused(value:Boolean):void {			if (_paused == value) { return; }			_paused = value;			if (value) {				ticker.removeEventListener("tick",handleTick);				// free this instance for collection:				if (_target is IEventDispatcher) { _target.removeEventListener("GDS__NONEXISTENT_EVENT", nullListener); }				delete(activeTweens[this]);			} else {				if (_state == BEGINNING || _state == END) {					_position = -_delay;					activate();				}				positionOffset = ticker.position-_position;				ticker.addEventListener("tick",handleTick);				// lock the tween in memory while it's active:				if (_target is IEventDispatcher) { _target.addEventListener("GDS__NONEXISTENT_EVENT", nullListener,false,0,false); }				else { activeTweens[this] = true; }			}		}		// public methods:		public function invalidate():void {			invalid = true;			if (_position > 0) { positionOffset = ticker.position-(_position = 0); } // ticker.interval			if (autoPlay) { paused = false; }			else if (_state == END) { _state = BEGINNING; }		}		public function reverse(reverseChildren:Boolean=true):void {			var o:Object = destProperties;			destProperties = initProperties;			initProperties = o;			invalid = false;			if (_state == TWEEN_PHASE) { positionOffset = ticker.position-(_position = _duration-_position); }			if (reverseChildren) {				for (var n:Object in children) { (n as GTween).reverse(); }			}			if (autoPlay) { play(); }		}		public function setTweenProperties(tweenProperties:Object):void {			if (!tweenProperties) { return; }			if ("duration" in tweenProperties) { // set duration first, because other properties (like position) may have dependencies. 				duration = tweenProperties.duration;				delete(tweenProperties.duration);			}						if ("activateListener" in tweenProperties) { addEventListener(Event.ACTIVATE,tweenProperties.activateListener,false,0,true); delete(tweenProperties.activateListener); }			if ("initListener" in tweenProperties) { addEventListener(Event.INIT,tweenProperties.initListener,false,0,true); delete(tweenProperties.initListener); }			if ("completeListener" in tweenProperties) { addEventListener(Event.COMPLETE,tweenProperties.completeListener,false,0,true); delete(tweenProperties.completeListener); }			if ("progressListener" in tweenProperties) { addEventListener(PROGRESS,tweenProperties.progressListener,false,0,true); delete(tweenProperties.progressListener); }			if ("changeListener" in tweenProperties) { addEventListener(Event.CHANGE,tweenProperties.changeListener,false,0,true); delete(tweenProperties.changeListener); }						for (var n:String in tweenProperties) {				this[n] = tweenProperties[n];			}		}		public function setAssignment(assignmentTarget:Object=null, assignmentProperty:String=null):void {			this.assignmentTarget = assignmentTarget;			this.assignmentProperty = assignmentProperty;		}				public function setProperty(propertyName:String,value:Number):void {			if (isNaN(value)) { return; }			if (_state == END) { reset(); }			destProperties[propertyName] = value;			invalidate();		}				public function getProperty(propertyName:String):Number {			return destProperties[propertyName];		}				/**		* Removes a destination value from the tween. This prevents the GTween instance from tweening the property.		*		* @param propertyName The name of the destination property to delete.		**/		public function deleteProperty(propertyName:String):Boolean {			return delete(destProperties[propertyName]);		}		public function setProperties(properties:Object):void {			if (!properties) { return; }			for (var key:String in properties) {				setProperty(key,properties[key]);			}		}				public function addChild(child:GTween,synchDuration:Boolean=true):void {			if (!child) { return; }			children[child] = synchDuration;			child.paused = true;			if (synchDuration) { child.duration = _duration; }		}				/**		* Removes a child tween.		*		* @param child The child GTween instance to remove.		**/		public function removeChild(child:GTween):void {			delete(children[child]);		}				/**		* Pauses the tween by stopping tick from being automatically called. This also releases the tween for garbage collection if		* it is not referenced externally.		**/		public function pause():void {			paused = true;		}		public function play():void {			paused = false;		}				/**		* Jumps the tween to its beginning and pauses it. This sets all target properties to their init values, and sets the state to BEGINNING.		**/		public function beginning():void {			updateProperties(0);			positionOffset = ticker.position-(_position = -_delay);			lastProgressPosition = -_delay;			for (var o:Object in children) { (o as GTween).beginning(); }			_state = BEGINNING;			paused = true;		}		public function end(endNextTween:Boolean=true):void {			position = _duration;			if (endNextTween && nextTween) { nextTween.end(); }		}		public function reset():void {			_position = -_delay;			_state = BEGINNING;			paused = true;			initProperties = _lastProgressPoint = null;			destProperties = {};		}		public function addProgressPoint(position:Number, data:*=null):void {			progressPoints.push(new ProgressPoint(position, data));			progressPoints.sortOn("position",Array.NUMERIC);		}				public function removeProgressPoint(position:Number, data:*=null):void {			for (var i:int=progressPoints.length-1; i>=0; i--) {				if (progressPoints[i].position == position && progressPoints[i].data == data) {					progressPoints.splice(i,1);				}			}		}				/**		* Removes all progress points.		**/		public function removeAllProgressPoints():void {			progressPoints = [];		}		public function clone(target:Object=null, preserveChildren:Boolean=false, preserveState:Boolean=false):GTween {			if (target == null) { target = this.target; }			var tween:GTween = new GTween(target, duration, destProperties, {assignmentProperty:assignmentProperty,							  									 assignmentTarget:assignmentTarget,																 autoHide:autoHide,																 autoPlay:autoPlay,																 autoReverse:autoReverse,																 delay:delay,																 nextTween:nextTween,																 ease:ease,																 useSmartRotation:useSmartRotation																 });						for (var o:Object in progressPoints) { tween.addProgressPoint(o.position, o.data); }						if (preserveChildren) {				for (o in children) { tween.addChild(o as GTween,children[o]); }			}			if (preserveState) {				tween.position = position;				tween.paused = paused;			}			return tween;		}				// overidden for optimization purposes.		/** @private **/		override public function dispatchEvent(evt:Event):Boolean {			// this is a lot more efficient for GTweens that don't have listeners for a particular event type.			if (hasEventListener(evt.type)) { return super.dispatchEvent(evt); }			return true;		}					// private methods:				// tick event handler.		/** @private **/		protected function handleTick(evt:Event):void {			if (GTween.pauseAll) { positionOffset = ticker.position-_position; return; }			var pos:Number = ticker.position - positionOffset;			setPosition((pos < _duration ? pos : _duration));		}				// sets position without doing any value checks, or updating the lastProgressPosition.		/** @private **/		protected function setPosition(value:Number):void {			if (value > _duration) { value = _duration; }			positionOffset = ticker.position-(_position = value);			update();		}				// called when the tween ends.		/** @private **/		protected function endTransition():void {			_state = END;			paused = true;			dispatchEvent(new Event(Event.COMPLETE));			if (autoReverse) { reverse(); }			if (nextTween) { nextTween.play(); }		}				// called when the tween moves from the DELAY_PHASE state to TWEEN_PHASE		/** @private **/		protected function init():void {			lastProgressPosition = -_delay;			_state = TWEEN_PHASE;			copyInitProperties();			dispatchEvent(new Event(Event.INIT));		}				// called when the tween first starts playing:		/** @private **/		protected function activate():void {			_state = (_position < 0) ? DELAY_PHASE : TWEEN_PHASE;			dispatchEvent(new Event(Event.ACTIVATE));			if (_position >= 0) { init(); }		}				// logic that runs each frame. Calculates position, updates properties, synchs children, handles events, etc.		/** @private **/		protected function update():void {			if (_state == BEGINNING || _state == END) { activate(); }			if (_position < 0) { return; }						// handle state:			if (_state == DELAY_PHASE) { init(); }			else if (_state == TWEEN_PHASE && invalid) { copyInitProperties(); }						var value:Number = _position >= _duration ? 1 : ease(_position/_duration, 0, 1, 1);			updateProperties(value);						if (hasAlphaAndVisible && _autoHide && destProperties["visible"] != null) { _target.visible = (_target.alpha > 0); }						for (var o:Object in children) { (o as GTween).position = _position; }						dispatchEvent(new Event(Event.CHANGE));			checkProgressPoints();						if (_position >= _duration) { endTransition(); }					}				// iterates all of the active properties and updates their values on the target.		/** @private **/		protected function updateProperties(value:Number):void {			var sizeSet:Boolean = false;			for (var n:String in destProperties) {				if (useSetSize && hasSetSize && (n == "width" || n == "height")) {					if (sizeSet) { continue; }					sizeSet = true;					var w:Number = (destProperties["width"] == null) ? _target.width : initProperties["width"]+(destProperties["width"]-initProperties["width"])*value;					var h:Number = (destProperties["height"] == null) ? _target.height : initProperties["height"]+(destProperties["height"]-initProperties["height"])*value;					if (useSnapping && snappingProperties["width"]) { w = Math.round(w); }					if (useSnapping && snappingProperties["height"]) { h = Math.round(h); }					_target["setSize"](w,h);				} else {					var val:Number = initProperties[n]+(destProperties[n]-initProperties[n])*value;					_target[n] = (useSnapping && snappingProperties[n]) ? Math.round(val) : val;				}			}			if (assignmentTarget && assignmentProperty) { assignmentTarget[assignmentProperty] = _target; }		}				// determines if any progress points have been passed, and fires progress points if they have.		/** @private **/		protected function checkProgressPoints():void {			if (progressPoints.length < 1) { return; }			if (lastProgressPosition > position) { trace("A PROGRESS POINT PROBLEM OCCURRED, PLEASE REPORT THIS BACK TO GSKINNER.COM"); lastProgressPosition = position; return; }						for (var i:uint=0; i<progressPoints.length; i++) {				var progressPoint:ProgressPoint = progressPoints[i] as ProgressPoint;				if (progressPoint.position <= lastProgressPosition) { continue; }				if (progressPoint.position > position) { break; }				_lastProgressPoint = progressPoint;				dispatchEvent(new Event(PROGRESS));			}			lastProgressPosition = position;		}				// copies the initial target properties into the local store.		/** @private **/		protected function copyInitProperties():void {			if (!invalid) { return; }			if (assignmentTarget && assignmentProperty) { _target = assignmentTarget[assignmentProperty]; }			initProperties = {};			for (var n:String in destProperties) {				if (useSmartRotation && rotationProperties[n]) {					var r:Number = destProperties[n] %360;					var tr:Number = _target[n] %360;					initProperties[n] = tr + ((Math.abs(tr-r) < 180) ? 0 : (tr>r) ? -360 : 360);				} else {					initProperties[n] = _target[n];				}			}			invalid = false;		}				// this is used as a listener for GC reasons.		/** @private **/		protected function nullListener(evt:Event):void { }	}}	import flash.utils.Proxy;import flash.utils.flash_proxy;import myleft.engine.GTween;dynamic class TargetProxy extends Proxy {		private var gTween:GTween;		public function TargetProxy(gTween:GTween):void {		this.gTween = gTween;	}	// proxy methods:	flash_proxy override function callProperty(methodName:*, ...args:Array):* {		return gTween.target[methodName].apply(null,args);	}		flash_proxy override function getProperty(prop:*):* {		var value:Number = gTween.getProperty(prop);		return (isNaN(value)) ? gTween.target[prop] : value;	}		flash_proxy override function setProperty(prop:*,value:*):void {		if (isNaN(value)) { gTween.target[prop] = value; }		else { gTween.setProperty(String(prop), Number(value)); }	}		flash_proxy override function deleteProperty(prop:*):Boolean {		return gTween.deleteProperty(prop);	}}class ProgressPoint {	public var position:Number;	public var data:*;		public function ProgressPoint(position:Number, data:*):void {		this.position = position;		this.data = data;	}}import flash.events.IEventDispatcher;interface ITicker extends IEventDispatcher {	function get position():Number;	function get interval():Number;}import flash.utils.getTimer;import flash.utils.Timer;import flash.events.EventDispatcher;import flash.events.Event;import flash.events.TimerEvent;class TimeTicker extends EventDispatcher implements ITicker {		protected var timer:Timer;		public function TimeTicker():void {		timer = new Timer(20);		timer.start();		timer.addEventListener(TimerEvent.TIMER,tick);	}		public function get position():Number {		return getTimer()/1000;	}		public function get interval():Number {		return timer.delay/1000;	}		public function set interval(value:Number):void {		timer.delay = value*1000;	}		protected function tick(evt:TimerEvent):void {		dispatchEvent(new Event("tick"));		evt.updateAfterEvent();	}}import flash.display.Shape;class FrameTicker extends EventDispatcher implements ITicker {		protected var shape:Shape;	protected var _position:Number=0;		public function FrameTicker():void {		shape = new Shape();		shape.addEventListener(Event.ENTER_FRAME,tick);	}		public function get interval():Number {		return 1;	}		public function get position():Number {		return _position;	}		protected function tick(evt:Event):void {		_position++;		dispatchEvent(new Event("tick"));	}}class HybridTicker extends EventDispatcher implements ITicker {		protected var shape:Shape;		public function HybridTicker():void {		shape = new Shape();		shape.addEventListener(Event.ENTER_FRAME,tick);	}		public function get position():Number {		return getTimer()/1000;	}		public function get interval():Number {		return 1;	}		protected function tick(evt:Event):void {		dispatchEvent(new Event("tick"));	}}